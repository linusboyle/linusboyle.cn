---
title: Vimscript 学习笔记
date: 2018-07-13
tags: 
    - Vim
    - Vimscript
    - Note
layout: post
---
作为一个vimer用了这么久vim，其实vimscript一直是一知半解，从刚开始接触的时候复制别人的配置，到现在的各种需求已经无法满足。看着自己1000+行的vimrc，看来是很有简化和优化的必要，这篇文章是学习vimscript的一些笔记。

### skills

这里是对使用技巧的补充，不涉及脚本。纯粹是在学脚本的过程中顺便学习到的（有点惭愧，:-\）

- CTRL-T 插入模式缩进当前行
- CTRL-D 插入模式反缩进当前行
- CTRL-W 插入模式删除前一个单词
- CTRL-U 插入模式删除行
- CTRL-A 增加数字
    - 插入模式下重复上一次插入模式插入的所有内容
- CRTL-X 减少数字（目前设置为0开头八进制 0x开头十六进制）

## 非脚本特性


### 实用命令
- execute 将字符串里的内容当作命令执行，同时对其中的特殊字符进行转义，比如\r，\\。后面需要<cr>
- normal 将命令当作普通模式的键入而操作，只是键入，不会解释<cr>之类的特殊字符，要这样做需要在外部使用execute输入特殊字

#### message
- :echo 打印消息，空格分割表达式 “\n”换行
    - 不会扩展，比如%，需要使用expand
    - 可以使用外部echo，%会被扩展但是会暂时退出vim
- :echom 打印消息，添加至消息历史，但是不打印特殊字符
- :messages 查看消息历史 大部分情况下可以记录100条(history可以设置记录条数)
    - :echo errmsg 可以打印错误信息

### 选项
- set <bool>
- set no<bool>
- set <bool>! 切换开关
- set <bool>? 查看当前值
- set <name> = <value>
- setlocal 设置选项为针对缓冲区，但并非所有时候都有效

- showmatch 插入配对符号时短暂跳转到对应符号 matchtime 设置十分之一秒数
- wrap 设置长行是否回旋
- shiftwidth 自动缩进空白数
- statusline 状态条显示的格式 注意空格需要转义

### map
- 普通的映射可以依次被解析，也许是优点，不过更多是缺点，只需要考虑递归的映射就可以了
- noremap 系列不会进行递归
    - 尽量使用非递归的映射 或者说得直白：只用noremap
- 在lfs前加入<buffer>创建本地映射。本地映射会覆盖全局映射
- onoremap 是对移动操作符的映射，只有在操作符之后接上这些映射才会生效
    - 结合本地映射、exe、normal、regex、自动命令可以相当强大

### leader
- :let mapleader=
- :let maplocalleader=

### 缩写
- iabbrev 插入模式下输入非字母数字下划线引发自动替换
- 和inoremap的不同是缩写只会对独立的单词有效
- 类似，加入<buffer>创建本地缩写

### 自动命令
- :autocmd <事件> <模式> <命令>
    - 可以创建绑定多个事件的自动命令
    - `BufRead` `BufNewFile`应该一起使用，这样无论是新建还是读取都有效
    - `BufWritePre` 写入数据前的操作
    - `FileType` 设置文件类型的事件
    - 和缩写结合，可以创建高效的snippets

### 自动命令组
- :augroup <name>
- :augroup END
- 可以给自动命令分组，之后主动调用或者删除的时候可以按组进行
- 有一个作用是防止重复定义相同的自动命令（重复载入配置时），只需要在组内加入autocmd!
    - autocmd!删除当前组的所有自动命令，不再组内则是默认的全局

## 脚本语言

- 管道符| 用于分割不同命令。命令被认为是独立而顺序执行

### 变量
- 变量用关键字let设置
- 选项可以作为变量使用，可以理解为对选项值“引用”
    - 格式为&选项名
- 选项也可以通过引用+let设置，和set的不同是可以通过脚本的特性在运行时计算选项值，而不是set所设置的固定值
    - 如:let &textwidth=&textwidth +10
- 寄存器的值也可以被作为变量。
    - 格式为@x
    - 寄存器：
        - _ 寄存器 类似于/dev/null，文档称为黑洞寄存器
        - 无名寄存器"是默认的寄存器，不管有没有指定目标，最近的操作都会被存在这个寄存器里
        - /寄存器存储了搜索模式
        - 英文字母代表的寄存器可以通过大写和小写访问，大写是追加，小写是覆盖。只有主动指定才使用这些
        - -寄存器是行内删除时存储删除内容的寄存器
        - 0寄存器是最近抽出的文本，除非特别指定
        - 1~9寄存器是最近删除或修改，且不存储在行内寄存器的文本。随着修改，寄存器的值依次复制到后一个寄存器。直到9寄存器后被丢弃
        - . 寄存器只读， 有最近插入的文本。类似于插入模式ctrl-a的效果
        - % 寄存器只读。有当前文件名
        - : 寄存器只读。保存上一次执行的命令行，但映射除外。可以用@:重复。
        - + * ~和gui剪贴板相关；
        - = 表达式寄存器。当使用@=时会交互输入表达式并执行
    - @x 执行寄存器的内容
    - qx 将按键输入存入寄存器

#### 变量作用域
- 字符: 代表作用域
- b:  局部于当前缓冲区。
- w:  局部于当前窗口。
- t:  局部于当前标签页。
- g:  全局。
- l:  局部于函数。
- s:  局部于:source的 Vim 脚本。
- a:  函数参数 (只限于函数内使用)。
- v:  Vim 预定义的全局变量。

### if
- if的判断值是通过整数来判断，其他类型的变量会被强制转换
    - 比如字符串，如不能转换为数字，则为0（false）
```
if command 
    dosomething
endif
```
- elseif
- else

#### 比较
- 字符串的==比较运算符 大小写是否敏感是由ignorecase的设置决定的
- 使用==#  无论如何大小写敏感
- 或者==?  无论如何大小写不敏感
 
